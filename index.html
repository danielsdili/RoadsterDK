<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>ROADSTER - Canvas Police Lights</title>

  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at top, #111, #000);
      font-family: Arial, sans-serif;
      overflow: hidden;
      color: white;
      touch-action: none;
    }

    #hud {
      width: 100%;
      max-width: 420px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      font-size: 15px;
      font-weight: bold;
      padding: 10px 14px;
      box-sizing: border-box;
      opacity: 0.95;
    }

    #wrap {
      width: 100%;
      max-width: 420px;
      margin: 0 auto;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 75vh;
      border: 4px solid #444;
      border-radius: 14px;
      background: linear-gradient(#1a1a1a, #0b0b0b);
      display: block;
      box-shadow: 0 0 20px rgba(255,255,255,0.08);
    }

    #controls {
      width: 100%;
      max-width: 420px;
      margin: 12px auto;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      padding: 0 12px;
      box-sizing: border-box;
    }

    .btn {
      flex: 1;
      height: 80px;
      border-radius: 18px;
      color: black;
      font-size: 34px;
      font-weight: 900;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;

      background: repeating-linear-gradient(
        45deg,
        #ffd500,
        #ffd500 12px,
        #111 12px,
        #111 24px
      );

      border: 3px solid #ffd500;
      box-shadow: 0 0 14px rgba(255,213,0,0.25);
      text-shadow: 0 0 6px rgba(0,0,0,0.8);
    }

    .btn:active {
      transform: scale(0.96);
      filter: brightness(1.2);
    }

    #gameOver {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.88);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
      z-index: 999;
      border-radius: 14px;
    }

    #gameOver h1 {
      margin: 0;
      font-size: 42px;
      color: gold;
      text-shadow: 0 0 15px rgba(255,215,0,0.3);
    }

    #gameOver p {
      margin: 12px 0;
      opacity: 0.9;
    }

    button {
      padding: 12px 18px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      cursor: pointer;
      background: gold;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(255,215,0,0.3);
    }
  </style>
</head>

<body>

<div id="hud">
  <div>Skóre: <span id="score">0</span></div>
  <div>Rychlost: <span id="speed">1</span>x</div>
</div>

<div id="wrap">
  <canvas id="game"></canvas>

  <div id="gameOver">
    <h1>CRASHED!</h1>
    <p>Tvoje skóre: <span id="finalScore">0</span></p>
    <button onclick="restartGame()">Zkusit znovu</button>
  </div>
</div>

<div id="controls">
  <div class="btn" id="leftBtn">◀</div>
  <div class="btn" id="rightBtn">▶</div>
</div>

<script>
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const speedEl = document.getElementById("speed");
  const gameOverScreen = document.getElementById("gameOver");
  const finalScoreEl = document.getElementById("finalScore");

  const leftBtn = document.getElementById("leftBtn");
  const rightBtn = document.getElementById("rightBtn");

  let w, h;

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * devicePixelRatio;
    canvas.height = rect.height * devicePixelRatio;
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);

    w = rect.width;
    h = rect.height;
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  let score = 0;
  let speed = 5;
  let frame = 0;
  let running = true;
  let crashed = false;
  let timeScale = 1;

  let holdingLeft = false;
  let holdingRight = false;

  const player = {
    x: w / 2,
    y: h - 140,
    width: 62,
    height: 118,
    targetX: w / 2,
    angle: 0,
    spinVel: 0
  };

  let laneLines = [];
  for (let i = 0; i < 12; i++) {
    laneLines.push({ x: w/2, y: i * 90 });
  }

  let enemies = [];
  let particles = [];
  let smokes = [];

  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function spawnEnemy() {
    const types = ["sedan", "sport", "taxi", "police", "van", "truck"];
    const type = types[Math.floor(Math.random() * types.length)];

    let ew = 54, eh = 104;
    if (type === "police") { ew = 62; eh = 118; }
    if (type === "truck") { ew = 64; eh = 118; }
    if (type === "van") { ew = 60; eh = 114; }

    enemies.push({
      x: rand(40, w - 100),
      y: -200,
      width: ew,
      height: eh,
      type,
      angle: 0,
      crashed: false,
      spinVel: 0,
      vx: rand(-1.2, 1.2)
    });
  }

  function drawRoad() {
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, "#1a1a1a");
    grad.addColorStop(1, "#0b0b0b");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    ctx.fillStyle = "rgba(255,215,0,0.35)";
    ctx.fillRect(0, 0, 10, h);
    ctx.fillRect(w - 10, 0, 10, h);

    ctx.fillStyle = "rgba(255,255,255,0.03)";
    ctx.fillRect(0, (frame * 3) % h - 80, w, 120);

    laneLines.forEach(line => {
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.fillRect(line.x - 5, line.y, 10, 80);
    });
  }

  function updateRoad() {
    laneLines.forEach(line => {
      line.y += speed * timeScale;
      if (line.y > h) line.y = -80;
    });
  }

  function roundRect(x, y, width, height, radius, fill) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + width, y, x + width, y + height, radius);
    ctx.arcTo(x + width, y + height, x, y + height, radius);
    ctx.arcTo(x, y + height, x, y, radius);
    ctx.arcTo(x, y, x + width, y, radius);
    ctx.closePath();
    if (fill) ctx.fill();
  }

  function drawPoliceLightCone(x, y, width, height) {
    const blink = (frame % 8 < 4);

    ctx.save();
    ctx.globalAlpha = blink ? 0.55 : 0.35;

    const coneGrad = ctx.createRadialGradient(
      x + width/2, y + 20, 10,
      x + width/2, y + 130, 140
    );

    if (blink) {
      coneGrad.addColorStop(0, "rgba(0,150,255,0.65)");
      coneGrad.addColorStop(0.4, "rgba(0,150,255,0.22)");
      coneGrad.addColorStop(1, "rgba(0,150,255,0)");
    } else {
      coneGrad.addColorStop(0, "rgba(255,0,0,0.55)");
      coneGrad.addColorStop(0.4, "rgba(255,0,0,0.18)");
      coneGrad.addColorStop(1, "rgba(255,0,0,0)");
    }

    ctx.fillStyle = coneGrad;
    roundRect(x - 40, y + 10, width + 80, height + 180, 90, true);

    ctx.restore();
  }

  function drawCar(x, y, width, height, colorTop, colorBottom, angle=0, label=null, siren=false) {
    ctx.save();
    ctx.translate(x + width/2, y + height/2);
    ctx.rotate(angle);

    const grad = ctx.createLinearGradient(0, -height/2, 0, height/2);
    grad.addColorStop(0, colorTop);
    grad.addColorStop(1, colorBottom);

    ctx.fillStyle = grad;
    roundRect(-width/2, -height/2, width, height, 16, true);

    ctx.fillStyle = "rgba(255,255,255,0.12)";
    roundRect(-width/2, -height/2, width, height * 0.5, 16, true);

    ctx.fillStyle = "rgba(255,255,255,0.15)";
    roundRect(-7, -height/2, 14, height, 10, true);

    ctx.fillStyle = "#111";
    roundRect(-width/2 + 10, -height/2 + 12, width - 20, 30, 8, true);

    ctx.fillStyle = "rgba(255,200,0,0.85)";
    roundRect(-width/2 + 8, height/2 - 24, width - 16, 14, 7, true);

    ctx.fillStyle = "#050505";
    ctx.fillRect(-width/2 - 5, -height/2 + 18, 10, 22);
    ctx.fillRect(-width/2 - 5, height/2 - 40, 10, 22);
    ctx.fillRect(width/2 - 5, -height/2 + 18, 10, 22);
    ctx.fillRect(width/2 - 5, height/2 - 40, 10, 22);

    if (label) {
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "bold 10px Arial";
      ctx.textAlign = "center";
      ctx.fillText(label, 0, 5);
    }

    if (siren) {
      const blink = (frame % 8 < 4);

      ctx.fillStyle = blink ? "rgba(0,150,255,1)" : "rgba(255,0,0,1)";
      roundRect(-18, -height/2 + 4, 36, 10, 6, true);

      // stronger glow around siren
      ctx.globalAlpha = blink ? 0.35 : 0.3;
      ctx.fillStyle = blink ? "rgba(0,150,255,1)" : "rgba(255,0,0,1)";
      roundRect(-55, -height/2 + 2, 110, 28, 20, true);
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function drawPlayer() {
    drawCar(player.x, player.y, player.width, player.height, "#ff1a1a", "#9c0000", player.angle, "ROADSTER", false);
  }

  function drawEnemies() {
    enemies.forEach(e => {
      if (e.type === "police") {
        drawPoliceLightCone(e.x, e.y, e.width, e.height);
      }

      if (e.type === "sedan") drawCar(e.x, e.y, e.width, e.height, "#999", "#333", e.angle);
      if (e.type === "sport") drawCar(e.x, e.y, e.width, e.height, "#00c6ff", "#003cff", e.angle);
      if (e.type === "taxi") drawCar(e.x, e.y, e.width, e.height, "#ffcc00", "#c48d00", e.angle, "TAXI");
      if (e.type === "van") drawCar(e.x, e.y, e.width, e.height, "#fff", "#aaa", e.angle);
      if (e.type === "truck") drawCar(e.x, e.y, e.width, e.height, "#666", "#222", e.angle);
      if (e.type === "police") drawCar(e.x, e.y, e.width, e.height, "#0c0c0c", "#222", e.angle, "POLICE", true);
    });
  }

  function updatePlayer() {
    if (!running) return;

    if (holdingLeft) player.targetX -= 7;
    if (holdingRight) player.targetX += 7;

    const minX = 20;
    const maxX = w - player.width - 20;

    if (player.targetX < minX) player.targetX = minX;
    if (player.targetX > maxX) player.targetX = maxX;

    player.x += (player.targetX - player.x) * 0.25;

    if (!crashed) {
      player.angle = (player.targetX - player.x) * 0.003;
    } else {
      player.angle += player.spinVel * timeScale;
      player.spinVel *= 0.98;
    }
  }

  function updateEnemies() {
    enemies.forEach((e, idx) => {
      if (!e.crashed) {
        e.y += (speed + 1.2) * timeScale;
        e.x += e.vx * timeScale;

        if (e.x < 20) e.x = 20;
        if (e.x > w - e.width - 20) e.x = w - e.width - 20;
      } else {
        e.y += (speed + 2.5) * timeScale;
        e.x += e.vx * 4 * timeScale;
        e.angle += e.spinVel * timeScale;
        e.spinVel *= 0.98;
      }

      if (e.y > h + 300) {
        enemies.splice(idx, 1);
        score += 10;
        scoreEl.textContent = score;
      }

      if (!crashed && checkCollision(player, e)) {
        crash(e);
      }
    });
  }

  function checkCollision(a, b) {
    return !(
      a.x > b.x + b.width ||
      a.x + a.width < b.x ||
      a.y > b.y + b.height ||
      a.y + a.height < b.y
    );
  }

  function crash(enemy) {
    crashed = true;
    timeScale = 0.12;

    player.spinVel = 0.35;

    enemy.crashed = true;
    enemy.spinVel = rand(0.25, 0.45);
    enemy.vx = rand(-2.5, 2.5);

    spawnParticles(player.x + player.width/2, player.y + player.height/2);
    spawnSmoke(player.x + player.width/2, player.y + player.height/2);

    setTimeout(() => {
      timeScale = 0;
      endGame();
    }, 5000);
  }

  function spawnParticles(x, y) {
    for (let i = 0; i < 30; i++) {
      particles.push({
        x,
        y,
        vx: rand(-9, 9),
        vy: rand(-9, 9),
        life: rand(25, 45),
        color: ["orange", "yellow", "red", "#ff6600", "#ffaa00", "#fff"][Math.floor(Math.random()*6)]
      });
    }
  }

  function spawnSmoke(x, y) {
    for (let i = 0; i < 7; i++) {
      smokes.push({
        x: x + rand(-25, 25),
        y: y + rand(-25, 25),
        vy: rand(-1.2, -2.5),
        life: rand(80, 130),
        size: rand(20, 40)
      });
    }
  }

  function drawParticles() {
    particles.forEach(p => {
      ctx.fillStyle = p.color;
      ctx.globalAlpha = Math.max(p.life / 45, 0);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    });
  }

  function updateParticles() {
    particles.forEach((p, idx) => {
      p.life -= 1 * timeScale;
      p.x += p.vx * timeScale;
      p.y += p.vy * timeScale;
      p.vx *= 0.97;
      p.vy *= 0.97;

      if (p.life <= 0) particles.splice(idx, 1);
    });

    smokes.forEach((s, idx) => {
      s.life -= 1 * timeScale;
      s.y += s.vy * timeScale;
      s.size += 0.2 * timeScale;

      if (s.life <= 0) smokes.splice(idx, 1);
    });
  }

  function drawSmoke() {
    smokes.forEach(s => {
      ctx.globalAlpha = Math.max(s.life / 130, 0) * 0.6;
      ctx.fillStyle = "rgba(120,120,120,0.8)";
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    });
  }

  function endGame() {
    running = false;
    finalScoreEl.textContent = score;
    gameOverScreen.style.display = "flex";
  }

  function restartGame() {
    score = 0;
    speed = 5;
    frame = 0;
    running = true;
    crashed = false;
    timeScale = 1;

    enemies = [];
    particles = [];
    smokes = [];

    scoreEl.textContent = score;
    speedEl.textContent = "1";

    player.x = w / 2;
    player.targetX = w / 2;
    player.angle = 0;
    player.spinVel = 0;

    gameOverScreen.style.display = "none";
  }

  window.restartGame = restartGame;

  leftBtn.addEventListener("touchstart", (e) => { e.preventDefault(); holdingLeft = true; });
  leftBtn.addEventListener("touchend", () => holdingLeft = false);

  rightBtn.addEventListener("touchstart", (e) => { e.preventDefault(); holdingRight = true; });
  rightBtn.addEventListener("touchend", () => holdingRight = false);

  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft") holdingLeft = true;
    if (e.key === "ArrowRight") holdingRight = true;
  });

  document.addEventListener("keyup", (e) => {
    if (e.key === "ArrowLeft") holdingLeft = false;
    if (e.key === "ArrowRight") holdingRight = false;
  });

  function loop() {
    if (running) {
      frame++;

      updateRoad();
      updatePlayer();
      updateEnemies();
      updateParticles();

      if (!crashed && frame % 70 === 0) spawnEnemy();

      if (!crashed && frame % 260 === 0) {
        speed += 0.45;
        speedEl.textContent = (speed / 5).toFixed(1);
      }
    }

    drawRoad();
    drawSmoke();
    drawEnemies();
    drawPlayer();
    drawParticles();

    requestAnimationFrame(loop);
  }

  loop();
</script>

</body>
</html>
