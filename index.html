<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>ROADSTER - Burnout Canvas Edition</title>

  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at top, #111, #000);
      font-family: Arial, sans-serif;
      overflow: hidden;
      color: white;
      touch-action: none;
    }

    #hud {
      width: 100%;
      max-width: 420px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      font-size: 15px;
      font-weight: bold;
      padding: 10px 14px;
      box-sizing: border-box;
      opacity: 0.95;
    }

    #wrap {
      width: 100%;
      max-width: 420px;
      margin: 0 auto;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 75vh;
      border: 4px solid #444;
      border-radius: 14px;
      background: linear-gradient(#1a1a1a, #0b0b0b);
      display: block;
      box-shadow: 0 0 20px rgba(255,255,255,0.08);
      transform-origin: center;
      transition: transform 0.55s ease;
    }

    canvas.zoom {
      transform: scale(1.08);
    }

    #controls {
      width: 100%;
      max-width: 420px;
      margin: 12px auto;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      padding: 0 12px;
      box-sizing: border-box;
    }

    .btn {
      flex: 1;
      height: 80px;
      border-radius: 18px;
      color: black;
      font-size: 34px;
      font-weight: 900;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;

      background: repeating-linear-gradient(
        45deg,
        #ffd500,
        #ffd500 12px,
        #111 12px,
        #111 24px
      );

      border: 3px solid #ffd500;
      box-shadow: 0 0 14px rgba(255,213,0,0.25);
      text-shadow: 0 0 6px rgba(0,0,0,0.8);
    }

    .btn:active {
      transform: scale(0.96);
      filter: brightness(1.2);
    }

    /* START SCREEN */
    #startScreen {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.95);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
      z-index: 999;
      border-radius: 14px;
      overflow: hidden;
    }

    #introText {
      font-size: 16px;
      font-weight: 900;
      letter-spacing: 3px;
      color: #ffd500;
      opacity: 0;
      transform: translateY(20px);
      animation: introFade 1.5s ease forwards;
    }

    #mainLogo {
      font-size: 58px;
      margin: 12px 0 0 0;
      color: gold;
      letter-spacing: 8px;
      text-shadow: 0 0 25px rgba(255,215,0,0.35);
      opacity: 0;
      transform: scale(0.8);
      animation: logoPop 1.8s ease forwards;
      animation-delay: 1.2s;
    }

    #subText {
      margin-top: 10px;
      font-size: 14px;
      opacity: 0;
      animation: subFade 1.4s ease forwards;
      animation-delay: 2.5s;
    }

    #startBtn {
      margin-top: 26px;
      padding: 16px 32px;
      border: none;
      border-radius: 14px;
      font-size: 20px;
      cursor: pointer;
      background: repeating-linear-gradient(
        45deg,
        #ffd500,
        #ffd500 12px,
        #111 12px,
        #111 24px
      );
      color: black;
      font-weight: 900;
      box-shadow: 0 0 20px rgba(255,215,0,0.25);
      opacity: 0;
      pointer-events: none;
      animation: btnShow 1.2s ease forwards;
      animation-delay: 3.6s;
    }

    #startBtn:active {
      transform: scale(0.96);
      filter: brightness(1.2);
    }

    /* intro flash */
    #introFlash {
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.95);
      opacity: 0;
      pointer-events: none;
      z-index: 1000;
    }

    .flashAnim {
      animation: flashBang 0.4s ease forwards;
      animation-delay: 2.1s;
    }

    @keyframes flashBang {
      0% { opacity: 0; }
      30% { opacity: 1; }
      100% { opacity: 0; }
    }

    @keyframes introFade {
      0% { opacity: 0; transform: translateY(20px); }
      100% { opacity: 1; transform: translateY(0px); }
    }

    @keyframes logoPop {
      0% { opacity: 0; transform: scale(0.75); }
      60% { opacity: 1; transform: scale(1.08); }
      100% { opacity: 1; transform: scale(1); }
    }

    @keyframes subFade {
      0% { opacity: 0; }
      100% { opacity: 0.85; }
    }

    @keyframes btnShow {
      0% { opacity: 0; transform: translateY(15px); }
      100% { opacity: 1; transform: translateY(0px); pointer-events: auto; }
    }

    /* GAME OVER */
    #gameOver {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.88);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
      z-index: 999;
      border-radius: 14px;
    }

    #gameOver h1 {
      margin: 0;
      font-size: 42px;
      color: gold;
      text-shadow: 0 0 15px rgba(255,215,0,0.3);
    }

    #gameOver p {
      margin: 12px 0;
      opacity: 0.9;
    }

    button {
      padding: 12px 18px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      cursor: pointer;
      background: gold;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(255,215,0,0.3);
    }
  </style>
</head>

<body>

<div id="hud">
  <div>Skóre: <span id="score">0</span></div>
  <div>Rychlost: <span id="speed">1</span>x</div>
</div>

<div id="wrap">
  <canvas id="game"></canvas>

  <div id="startScreen">
    <div id="introFlash" class="flashAnim"></div>

    <div id="introText">DANIEL_SDILI UVÁDÍ:</div>
    <div id="mainLogo">ROADSTER</div>
    <div id="subText">Burnout Canvas Edition</div>

    <button id="startBtn">START</button>
  </div>

  <div id="gameOver">
    <h1>CRASHED!</h1>
    <p>Tvoje skóre: <span id="finalScore">0</span></p>
    <button onclick="restartGame()">Zkusit znovu</button>
  </div>
</div>

<div id="controls">
  <div class="btn" id="leftBtn">◀</div>
  <div class="btn" id="rightBtn">▶</div>
</div>

<script>
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const speedEl = document.getElementById("speed");

  const gameOverScreen = document.getElementById("gameOver");
  const finalScoreEl = document.getElementById("finalScore");

  const startScreen = document.getElementById("startScreen");
  const startBtn = document.getElementById("startBtn");

  const leftBtn = document.getElementById("leftBtn");
  const rightBtn = document.getElementById("rightBtn");

  let w, h;

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * devicePixelRatio;
    canvas.height = rect.height * devicePixelRatio;
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    w = rect.width;
    h = rect.height;
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  let score = 0;
  let speed = 5;
  let frame = 0;

  let running = false;
  let crashed = false;
  let timeScale = 1;

  let holdingLeft = false;
  let holdingRight = false;

  // CAMERA FX
  let camShake = 0;

  const player = {
    x: 0,
    y: 0,
    width: 62,
    height: 118,
    targetX: 0,
    angle: 0,
    spinVel: 0
  };

  let laneLines = [];
  function resetRoad() {
    laneLines = [];
    for (let i = 0; i < 12; i++) {
      laneLines.push({ x: w/2, y: i * 90 });
    }
  }
  resetRoad();

  let enemies = [];
  let sparks = [];
  let smokes = [];
  let explosions = [];

  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function roundRect(x, y, width, height, radius, fill) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + width, y, x + width, y + height, radius);
    ctx.arcTo(x + width, y + height, x, y + height, radius);
    ctx.arcTo(x, y + height, x, y, radius);
    ctx.arcTo(x, y, x + width, y, radius);
    ctx.closePath();
    if (fill) ctx.fill();
  }

  function spawnEnemy() {
    const types = ["sedan", "sport", "taxi", "police", "van", "truck"];
    const type = types[Math.floor(Math.random() * types.length)];

    let ew = 54, eh = 104;
    if (type === "police") { ew = 62; eh = 118; }
    if (type === "truck") { ew = 64; eh = 118; }
    if (type === "van") { ew = 60; eh = 114; }

    enemies.push({
      x: rand(40, w - 100),
      y: -200,
      width: ew,
      height: eh,
      type,
      angle: 0,
      crashed: false,
      spinVel: 0,
      vx: rand(-1.2, 1.2)
    });
  }

  function updateRoad() {
    laneLines.forEach(line => {
      line.y += speed * timeScale;
      if (line.y > h) line.y = -80;
    });
  }

  function drawRoadTexture() {
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, "#1a1a1a");
    grad.addColorStop(1, "#0b0b0b");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    ctx.globalAlpha = 0.22;
    for (let i = 0; i < 10; i++) {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, (i * 120 + (frame * 2)) % (h + 200) - 200, w, 70);
    }
    ctx.globalAlpha = 1;

    ctx.globalAlpha = 0.10;
    for (let i = 0; i < 180; i++) {
      ctx.fillStyle = (Math.random() > 0.5) ? "rgba(255,255,255,0.25)" : "rgba(0,0,0,0.25)";
      ctx.fillRect(Math.random() * w, Math.random() * h, 1, 1);
    }
    ctx.globalAlpha = 1;

    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    for (let i = 0; i < 5; i++) {
      ctx.fillRect(w/2 - 70, (i * 160 + (frame * 3)) % (h + 200) - 200, 18, 110);
      ctx.fillRect(w/2 + 50, (i * 160 + (frame * 3)) % (h + 200) - 200, 18, 110);
    }
    ctx.globalAlpha = 1;

    ctx.fillStyle = "rgba(255,215,0,0.35)";
    ctx.fillRect(0, 0, 10, h);
    ctx.fillRect(w - 10, 0, 10, h);

    ctx.globalAlpha = 0.08;
    ctx.fillStyle = "rgba(255,255,255,1)";
    ctx.fillRect(0, (frame * 3) % h - 100, w, 140);
    ctx.globalAlpha = 1;

    laneLines.forEach(line => {
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.fillRect(line.x - 5, line.y, 10, 80);
    });
  }

  function drawPoliceLightCone(x, y, width, height) {
    const blink = (frame % 6 < 3); // 2x faster blink

    ctx.save();
    ctx.globalAlpha = blink ? 0.7 : 0.5;

    const coneGrad = ctx.createRadialGradient(
      x + width/2, y + 20, 10,
      x + width/2, y + 140, 180
    );

    if (blink) {
      coneGrad.addColorStop(0, "rgba(0,150,255,0.85)");
      coneGrad.addColorStop(0.45, "rgba(0,150,255,0.25)");
      coneGrad.addColorStop(1, "rgba(0,150,255,0)");
    } else {
      coneGrad.addColorStop(0, "rgba(255,0,0,0.85)");
      coneGrad.addColorStop(0.45, "rgba(255,0,0,0.25)");
      coneGrad.addColorStop(1, "rgba(255,0,0,0)");
    }

    ctx.fillStyle = coneGrad;
    roundRect(x - 60, y + 10, width + 120, height + 260, 120, true);

    ctx.restore();
  }

  function drawCar(x, y, width, height, colorTop, colorBottom, angle=0, label=null, siren=false) {
    ctx.save();
    ctx.translate(x + width/2, y + height/2);
    ctx.rotate(angle);

    const grad = ctx.createLinearGradient(0, -height/2, 0, height/2);
    grad.addColorStop(0, colorTop);
    grad.addColorStop(1, colorBottom);

    ctx.fillStyle = grad;
    roundRect(-width/2, -height/2, width, height, 16, true);

    ctx.fillStyle = "rgba(255,255,255,0.12)";
    roundRect(-width/2, -height/2, width, height * 0.5, 16, true);

    ctx.fillStyle = "rgba(255,255,255,0.15)";
    roundRect(-7, -height/2, 14, height, 10, true);

    ctx.fillStyle = "#111";
    roundRect(-width/2 + 10, -height/2 + 12, width - 20, 30, 8, true);

    ctx.fillStyle = "rgba(255,200,0,0.85)";
    roundRect(-width/2 + 8, height/2 - 24, width - 16, 14, 7, true);

    ctx.fillStyle = "#050505";
    ctx.fillRect(-width/2 - 5, -height/2 + 18, 10, 22);
    ctx.fillRect(-width/2 - 5, height/2 - 40, 10, 22);
    ctx.fillRect(width/2 - 5, -height/2 + 18, 10, 22);
    ctx.fillRect(width/2 - 5, height/2 - 40, 10, 22);

    if (label) {
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "bold 10px Arial";
      ctx.textAlign = "center";
      ctx.fillText(label, 0, 5);
    }

    if (siren) {
      const blink = (frame % 6 < 3);

      ctx.fillStyle = blink ? "rgba(0,150,255,1)" : "rgba(255,0,0,1)";
      roundRect(-18, -height/2 + 4, 36, 10, 6, true);

      ctx.globalAlpha = blink ? 0.45 : 0.4;
      ctx.fillStyle = blink ? "rgba(0,150,255,1)" : "rgba(255,0,0,1)";
      roundRect(-70, -height/2 + 0, 140, 36, 20, true);
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function drawPlayer() {
    drawCar(player.x, player.y, player.width, player.height, "#ff1a1a", "#9c0000", player.angle, "ROADSTER", false);
  }

  function drawEnemies() {
    enemies.forEach(e => {
      if (e.type === "police") drawPoliceLightCone(e.x, e.y, e.width, e.height);

      if (e.type === "sedan") drawCar(e.x, e.y, e.width, e.height, "#999", "#333", e.angle);
      if (e.type === "sport") drawCar(e.x, e.y, e.width, e.height, "#00c6ff", "#003cff", e.angle);
      if (e.type === "taxi") drawCar(e.x, e.y, e.width, e.height, "#ffcc00", "#c48d00", e.angle, "TAXI");
      if (e.type === "van") drawCar(e.x, e.y, e.width, e.height, "#fff", "#aaa", e.angle);
      if (e.type === "truck") drawCar(e.x, e.y, e.width, e.height, "#666", "#222", e.angle);
      if (e.type === "police") drawCar(e.x, e.y, e.width, e.height, "#0c0c0c", "#222", e.angle, "POLICE", true);
    });
  }

  function updatePlayer() {
    if (!running) return;

    if (holdingLeft) player.targetX -= 7;
    if (holdingRight) player.targetX += 7;

    const minX = 20;
    const maxX = w - player.width - 20;

    if (player.targetX < minX) player.targetX = minX;
    if (player.targetX > maxX) player.targetX = maxX;

    player.x += (player.targetX - player.x) * 0.25;

    if (!crashed) {
      player.angle = (player.targetX - player.x) * 0.003;
    } else {
      player.angle += player.spinVel * timeScale;
      player.spinVel *= 0.98;
    }
  }

  function updateEnemies() {
    enemies.forEach((e, idx) => {
      if (!e.crashed) {
        e.y += (speed + 1.2) * timeScale;
        e.x += e.vx * timeScale;

        if (e.x < 20) e.x = 20;
        if (e.x > w - e.width - 20) e.x = w - e.width - 20;
      } else {
        e.y += (speed + 2.5) * timeScale;
        e.x += e.vx * 4 * timeScale;
        e.angle += e.spinVel * timeScale;
        e.spinVel *= 0.98;
      }

      if (e.y > h + 300) {
        enemies.splice(idx, 1);
        score += 10;
        scoreEl.textContent = score;
      }

      if (!crashed && checkCollision(player, e)) crash(e);
    });
  }

  function checkCollision(a, b) {
    return !(
      a.x > b.x + b.width ||
      a.x + a.width < b.x ||
      a.y > b.y + b.height ||
      a.y + a.height < b.y
    );
  }

  function spawnExplosion(x, y) {
    explosions.push({ x, y, radius: 10, life: 55 });
  }

  function spawnSparks(x, y) {
    for (let i = 0; i < 55; i++) {
      sparks.push({
        x, y,
        vx: rand(-22, 22),
        vy: rand(-24, 24),
        life: rand(45, 95),
        size: rand(4, 10),
        color: ["orange", "yellow", "#ff6600", "#ffaa00", "#ffffff"][Math.floor(Math.random()*5)]
      });
    }
  }

  function spawnSmoke(x, y) {
    for (let i = 0; i < 12; i++) {
      smokes.push({
        x: x + rand(-35, 35),
        y: y + rand(-35, 35),
        vy: rand(-1.2, -3.2),
        life: rand(120, 200),
        size: rand(30, 65)
      });
    }
  }

  function drawExplosions() {
    explosions.forEach(ex => {
      ctx.save();

      ctx.globalAlpha = Math.max(ex.life / 55, 0) * 0.75;
      ctx.strokeStyle = "rgba(255,220,120,0.9)";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.arc(ex.x, ex.y, ex.radius * 2.7, 0, Math.PI * 2);
      ctx.stroke();

      const g = ctx.createRadialGradient(ex.x, ex.y, 5, ex.x, ex.y, ex.radius * 5);
      g.addColorStop(0, "rgba(255,255,230,1)");
      g.addColorStop(0.3, "rgba(255,200,0,0.95)");
      g.addColorStop(0.65, "rgba(255,50,0,0.7)");
      g.addColorStop(1, "rgba(255,0,0,0)");

      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(ex.x, ex.y, ex.radius * 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    });
  }

  function updateExplosions() {
    explosions.forEach((ex, idx) => {
      ex.life -= 1 * timeScale;
      ex.radius += 1.5 * timeScale;
      if (ex.life <= 0) explosions.splice(idx, 1);
    });
  }

  function drawSparks() {
    sparks.forEach(s => {
      ctx.globalAlpha = Math.max(s.life / 95, 0);

      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha *= 0.8;
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x - s.vx * 1.1, s.y - s.vy * 1.1);
      ctx.stroke();

      ctx.globalAlpha = 1;
    });
  }

  function updateSparks() {
    sparks.forEach((s, idx) => {
      s.life -= 1 * timeScale;
      s.x += s.vx * timeScale;
      s.y += s.vy * timeScale;
      s.vx *= 0.97;
      s.vy *= 0.97;
      if (s.life <= 0) sparks.splice(idx, 1);
    });
  }

  function drawSmoke() {
    smokes.forEach(s => {
      ctx.globalAlpha = Math.max(s.life / 200, 0) * 0.6;
      ctx.fillStyle = "rgba(120,120,120,0.9)";
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    });
  }

  function updateSmoke() {
    smokes.forEach((s, idx) => {
      s.life -= 1 * timeScale;
      s.y += s.vy * timeScale;
      s.size += 0.3 * timeScale;
      if (s.life <= 0) smokes.splice(idx, 1);
    });
  }

  function crash(enemy) {
    crashed = true;
    timeScale = 0.12;
    player.spinVel = 0.35;

    camShake = 18;

    enemy.crashed = true;
    enemy.spinVel = rand(0.25, 0.45);
    enemy.vx = rand(-2.5, 2.5);

    const cx = player.x + player.width / 2;
    const cy = player.y + player.height / 2;

    spawnExplosion(cx, cy);
    spawnSparks(cx, cy);
    spawnSmoke(cx, cy);

    setTimeout(() => {
      timeScale = 0;
      endGame();
    }, 5000);
  }

  function endGame() {
    running = false;
    finalScoreEl.textContent = score;
    gameOverScreen.style.display = "flex";
  }

  function restartGame() {
    score = 0;
    speed = 5;
    frame = 0;
    running = false;
    crashed = false;
    timeScale = 1;

    enemies = [];
    sparks = [];
    smokes = [];
    explosions = [];

    scoreEl.textContent = score;
    speedEl.textContent = "1";

    player.x = w / 2 - player.width/2;
    player.targetX = player.x;
    player.y = h - 140;
    player.angle = 0;
    player.spinVel = 0;

    gameOverScreen.style.display = "none";
    startScreen.style.display = "flex";
  }

  window.restartGame = restartGame;

  startBtn.addEventListener("click", () => {
    startScreen.style.display = "none";

    canvas.classList.add("zoom");
    camShake = 12;

    setTimeout(() => {
      canvas.classList.remove("zoom");
    }, 600);

    setTimeout(() => {
      score = 0;
      speed = 5;
      frame = 0;
      crashed = false;
      timeScale = 1;

      enemies = [];
      sparks = [];
      smokes = [];
      explosions = [];

      resetRoad();

      player.x = w / 2 - player.width/2;
      player.targetX = player.x;
      player.y = h - 140;

      running = true;
    }, 600);
  });

  leftBtn.addEventListener("touchstart", (e) => { e.preventDefault(); holdingLeft = true; });
  leftBtn.addEventListener("touchend", () => holdingLeft = false);

  rightBtn.addEventListener("touchstart", (e) => { e.preventDefault(); holdingRight = true; });
  rightBtn.addEventListener("touchend", () => holdingRight = false);

  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft") holdingLeft = true;
    if (e.key === "ArrowRight") holdingRight = true;
  });

  document.addEventListener("keyup", (e) => {
    if (e.key === "ArrowLeft") holdingLeft = false;
    if (e.key === "ArrowRight") holdingRight = false;
  });

  function loop() {
    ctx.save();

    // CAMERA SHAKE
    if (camShake > 0) {
      const dx = rand(-camShake, camShake) * 0.2;
      const dy = rand(-camShake, camShake) * 0.2;
      ctx.translate(dx, dy);
      camShake *= 0.9;
    }

    if (running) {
      frame++;

      updateRoad();
      updatePlayer();
      updateEnemies();

      updateExplosions();
      updateSparks();
      updateSmoke();

      if (!crashed && frame % 70 === 0) spawnEnemy();

      if (!crashed && frame % 260 === 0) {
        speed += 0.45;
        speedEl.textContent = (speed / 5).toFixed(1);
      }
    }

    drawRoadTexture();
    drawEnemies();
    drawPlayer();
    drawSmoke();
    drawExplosions();
    drawSparks();

    ctx.restore();

    requestAnimationFrame(loop);
  }

  player.x = w / 2 - player.width/2;
  player.targetX = player.x;
  player.y = h - 140;

  requestAnimationFrame(loop);
</script>

</body>
</html>
